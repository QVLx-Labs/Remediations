#!/usr/bin/env bash

# Remediation for CVE-2025-24032
# -----------------------------------------------------------------------------------------------------
# Only matters if libpam-pkcs11 is installed and being used in PAM
#
# Items:
#   Acts only if pam_pkcs11 is used
#   Finds real conf path (respects config_file= in /etc/pam.d/*)
#   Creates minimal conf if missing
#   Backs up once
#   Inside each pkcs11_module, appends one merged cert_policy line (keeps ca/ocsp/etc; removes 'none')
#   No deletions; last-wins line becomes authoritative
# ----------------------------------------------------------------------------------------------------
# Author: $t@$h, QVLx Labs

set -euo pipefail

die(){ echo "ERROR: $*" >&2; exit 1; }
note(){ echo "$@" >&2; }
as_root(){ [ "${EUID:-$(id -u)}" -eq 0 ] || die "Run as root (sudo)."; }

pam_in_use(){
  grep -R -E '^\s*(auth|account|password|session)\s+[^#]*pam_pkcs11\.so(\b|$)' /etc/pam.d 2>/dev/null | grep -q .
}

find_conf_from_pam(){
  local p
  p="$(grep -R -E 'pam_pkcs11\.so[^#]*config_file=([^[:space:]]+)' /etc/pam.d 2>/dev/null \
      | sed -E 's/.*config_file=([^[:space:]]+).*/\1/' | head -n1 || true)"
  [ -n "$p" ] && { printf "%s" "$p"; return; }
  for c in /etc/pam_pkcs11/pam_pkcs11.conf /etc/pam_pkcs11.conf /etc/security/pam_pkcs11.conf; do
    [ -f "$c" ] && { printf "%s" "$c"; return; }
  done
  printf "%s" /etc/pam_pkcs11/pam_pkcs11.conf
}

ensure_conf_exists(){
  local f="$1"; mkdir -p -- "$(dirname -- "$f")"
  if [ ! -f "$f" ]; then
    cat > "$f" <<'EOF'
# Created by pam-pkcs11-harden-merged.sh
pkcs11_module opensc {
    # placeholder block; real deployments may define module path/CA/CRL/mapper
}
EOF
    note "Created minimal config at $f"
  fi
}

backup_once(){
  local f="$1"
  local b="${f}.bak.$(date +%Y%m%d%H%M%S)"
  cp -a -- "$f" "$b"
  note "Backup: $b"
}

main(){
  as_root
  if ! pam_in_use; then
    note "pam_pkcs11 is NOT referenced in /etc/pam.d → nothing to do."
    exit 0
  fi
  note "Detected pam_pkcs11 usage."

  local CONF; CONF="$(find_conf_from_pam)"
  ensure_conf_exists "$CONF"

  # If there are no module blocks, don't scribble.
  if ! grep -qE '^[[:space:]]*pkcs11_module[[:space:]]+[A-Za-z0-9_.-]+' "$CONF"; then
    note "No pkcs11_module blocks found in $CONF → nothing to change."
    exit 0
  fi

  backup_once "$CONF"

  local TMP="${CONF}.tmp.$$"
  awk '
    function ltrim(s){ sub(/^[ \t]+/, "", s); return s }
    function rtrim(s){ sub(/[ \t]+$/, "", s); return s }
    function trim(s){ return rtrim(ltrim(s)) }
    function add_token(tok,  k){
      tok=trim(tok)
      if(tok=="") return
      # normalize token name
      k=tok
      # drop explicit "none" (conflicts with any checks)
      if(k=="none") return
      if(!(k in seen)){
        seen[k]=1
        order[++n]=k
      }
    }
    function parse_policy(line,  p, i, t, cnt){
      gsub(/;[[:space:]]*$/,"",line)
      sub(/^[[:space:]]*cert_policy[[:space:]]*=[[:space:]]*/,"",line)
      cnt=split(line, p, /[,[:space:]]+/)
      for(i=1;i<=cnt;i++){ t=trim(p[i]); if(t!="") add_token(t) }
    }
    function policy_string(  i, out){
      # ensure signature present
      if(!("signature" in seen)){ add_token("signature") }
      out=""
      for(i=1;i<=n;i++){ out = (out=="" ? order[i] : out ", " order[i]) }
      return out
    }

    BEGIN{ inblk=0; n=0; last_policy_norm=""; had_policy=0 }

    /^[[:space:]]*pkcs11_module[[:space:]]+[A-Za-z0-9_.-]+[[:space:]]*\{/ {
      print; inblk=1; delete seen; delete order; n=0; last_policy_norm=""; had_policy=0
      next
    }

    inblk && /^[[:space:]]*cert_policy[[:space:]]*=/ {
      # accumulate union of tokens for the block; remember *this* line as last seen
      line=$0; parse_policy(line); had_policy=1
      # store a normalized string for the last-seen policy
      # (without trailing ; and normalized spacing)
      norm=line; gsub(/;[[:space:]]*$/,"",norm)
      gsub(/^[[:space:]]*cert_policy[[:space:]]*=[[:space:]]*/,"",norm)
      # normalize spaces around commas
      gsub(/[[:space:]]*,[[:space:]]*/,", ",norm); norm=trim(norm)
      last_policy_norm=norm
      print; next
    }

    inblk && /^[[:space:]]*\}/ {
      # Build merged policy string from union of tokens, forcing signature and removing none
      merged=policy_string()
      # If there was no cert_policy at all, or last one differs / lacks signature ⇒ append one line
      need_append = (had_policy==0 || last_policy_norm != merged)
      if(need_append){
        # preserve indentation of closing brace as base
        match($0, /^[[:space:]]*/); pad=substr($0,RSTART,RLENGTH)
        print pad "    cert_policy = " merged ";"
      }
      print; inblk=0; next
    }

    { print }
  ' "$CONF" > "$TMP"

  mv -- "$TMP" "$CONF"

  # Ensure each block now has a cert_policy that includes signature
  if awk '
    BEGIN{inblk=0; saw=0; bad=0; any=0}
    /^[[:space:]]*pkcs11_module[[:space:]]+[A-Za-z0-9_.-]+[[:space:]]*\{/ {inblk=1; saw=0; any=1; next}
    inblk && /^[[:space:]]*cert_policy[[:space:]]*=/ { if($0 ~ /signature/) saw=1; next }
    inblk && /^[[:space:]]*\}/ { if(saw==0) bad=1; inblk=0; next }
    END{ if(any==0 || bad==1) exit 1; else exit 0 }
  ' "$CONF"; then
    echo "SECURE: $CONF enforces cert_policy with signature (merged without dropping ca/ocsp/etc)."
  else
    die "Post-audit failed—see backup and $CONF."
  fi
}

main "$@"
